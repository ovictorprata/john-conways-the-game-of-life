{"ast":null,"code":"import Cell from \"@/components/GridCell.vue\";\nimport Stats from \"@/components/StatsApp.vue\";\nexport default {\n  components: {\n    \"app-cell\": Cell,\n    \"app-stats\": Stats\n  },\n  props: {\n    message: {\n      default: \"\",\n      type: String\n    },\n    importToken: {\n      default: \"\",\n      type: String\n    },\n    currentSpeed: {\n      default: 0,\n      type: Number\n    }\n  },\n  data() {\n    return {\n      width: 46,\n      height: 20,\n      gridList: [],\n      // Stats that get passed down to the app-stats component\n      currentTick: 0,\n      cellCount: 0,\n      cellsAlive: 0,\n      cellsCreated: 0,\n      // A prop that gets used by the app-cell component (drag)\n      isMouseDown: false\n    };\n  },\n  computed: {},\n  watch: {\n    /**\n     * Watches for changes in the message prop\n     * that gets passed down from the App component\n     * and then handles the input on a specific tick.\n     *\n     * @param {string} val - the value\n     */\n    message: function (val) {\n      if (val === \"nextStep\") {\n        this.update();\n        this.currentTick++;\n      } else if (val === \"redoSession\") {\n        this.reset();\n      } else if (val === \"randomSeed\") {\n        this.randomSeed();\n      }\n    }\n  },\n  created() {\n    this.cellCalc();\n  },\n  methods: {\n    /**\n     * Creates a 2D-Array during runtime for\n     * the website to use for most operations.\n     */\n    cellCalc: function () {\n      for (let i = 0; i < this.width; i++) {\n        this.gridList[i] = [];\n        for (let j = 0; j < this.height; j++) {\n          this.gridList[i][j] = {\n            isAlive: false\n          };\n        }\n      }\n      this.cellCount = this.width * this.height;\n    },\n    /**\n     * Changes the 'isAlive' object property\n     * of a specific cell to the one requested\n     * in the param.\n     *\n     * Usage to describe params\n     *\n     * @param {number} x - the x position\n     * @param {number} y - the y position\n     * @param {boolean} bool - the new boolean\n     */\n    setCell: function (x, y, bool) {\n      if (this.gridList[x][y].isAlive != bool) {\n        this.gridList[x][y].isAlive = bool;\n        this.updateCellCount(bool);\n      }\n      // let row = this.gridList[x];\n      // row.splice(y, 1, {isAlive: true});\n      // this.gridList.splice(x, 1, row);\n    },\n\n    /**\n     * The main function that updates the grid\n     * every tick based on the game of life rules.\n     */\n    update: function () {\n      let tempArr = [];\n      for (let i = 0; i < this.width; i++) {\n        tempArr[i] = [];\n        for (let j = 0; j < this.height; j++) {\n          let status = this.gridList[i][j].isAlive;\n          let neighbours = this.getNeighbours(i, j);\n          let result = false;\n          // Rule 1:\n          // Any live cell with fewer than two live neighbours dies,\n          // as if by under population\n          if (status && neighbours < 2) {\n            result = false;\n          }\n          // Rule 2:\n          // Any live cell with two or three neighbours lives on\n          // to the next generation\n          if (status && neighbours == 2 || neighbours == 3) {\n            result = true;\n          }\n          // Rule 3:\n          // Any live cell with more than three live neighbours dies,\n          // as if by overpopulation\n          if (status && neighbours > 3) {\n            result = false;\n          }\n          // Rule 4:\n          // Any dead cell with exactly three live neighbours becomes\n          // a live cell, as if by reproduction\n          if (!status && neighbours == 3) {\n            result = true;\n          }\n          tempArr[i][j] = result;\n        }\n      }\n      // set new gridList content\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          this.setCell(i, j, tempArr[i][j]);\n        }\n      }\n    },\n    /**\n     * Returns the amount of neighbours for\n     * a specific cell on the grid.\n     *\n     * @param {number} posX - the x position\n     * @param {number} posY - the Y position\n     * @return {number} neighbours - amount of neighbours\n     */\n    getNeighbours: function (posX, posY) {\n      let neighbours = 0;\n      if (posX <= this.width && posY <= this.height) {\n        for (let offsetX = -1; offsetX < 2; offsetX++) {\n          for (let offsetY = -1; offsetY < 2; offsetY++) {\n            let newX = posX + offsetX;\n            let newY = posY + offsetY;\n            // check if offset is:\n            // on current cell, out of bounds and if isAlive\n            // for cell true\n            if ((offsetX != 0 || offsetY != 0) && newX >= 0 && newX < this.width && newY >= 0 && newY < this.height && this.gridList[posX + offsetX][posY + offsetY].isAlive == true) {\n              neighbours++;\n            }\n          }\n        }\n      }\n      return neighbours;\n    },\n    /**\n     * Resets all gridList cells back to the\n     * start value.\n     */\n    reset: function () {\n      this.currentTick = 0;\n      this.cellsAlive = 0;\n      this.cellsCreated = 0;\n      this.gridList.forEach(col => {\n        col.forEach(cell => {\n          cell.isAlive = false;\n        });\n      });\n    },\n    /**\n     * Populates and overwrites gridList with cells.\n     */\n    randomSeed: function () {\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          let rand = Math.random();\n          if (rand < 0.2) {\n            this.setCell(i, j, true);\n          } else {\n            this.setCell(i, j, false);\n          }\n        }\n      }\n    },\n    /**\n     * Resets and then imports new cells into the gridList\n     * based on the importToken prop that gets passed down\n     * App.vue.\n     * The importToken is a string and its syntax looks\n     * like this:\n     * '[xPos,yPos],[xPos,yPos]...'.\n     */\n    /**\n     * Uses gridList to create an exportToken and\n     * emits it up to App.vue for the user to copy.\n     * Same format as in importToken().\n     */\n    exportSession: function () {\n      let exportToken = \"\";\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          if (this.gridList[i][j].isAlive) {\n            exportToken += \"[\" + i + \",\" + j + \"]\";\n          }\n        }\n      }\n      this.$emit(\"exportToken\", exportToken);\n    },\n    /**\n     * Updates the current cellcount on each new tick.\n     *\n     * @param {boolean} bool - boolean based on cell isAlive status\n     */\n    updateCellCount: function (bool) {\n      if (bool) {\n        this.cellsAlive++;\n        this.cellsCreated++;\n      } else {\n        this.cellsAlive--;\n      }\n    }\n  }\n};","map":{"version":3,"mappings":"AA+BA;AACA;AACA;EACAA;IACA;IACA;EACA;EACAC;IACAC;MACAC;MACAC;IACA;IACAC;MACAF;MACAC;IACA;IACAE;MACAH;MACAC;IACA;EACA;EACAG;IACA;MACAC;MACAC;MACAC;MACA;MACAC;MACAC;MACAC;MACAC;MACA;MACAC;IACA;EACA;EACAC;EACAC;IACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAf;MACA;QACA;QACA;MACA;QACA;MACA;QACA;MACA;IACA;EACA;EACAgB;IACA;EACA;EACAC;IACA;AACA;AACA;AACA;IACAC;MACA;QACA;QACA;UACA;YAAAC;UAAA;QACA;MACA;MACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACA;QACA;MACA;MACA;MACA;MACA;IACA;;IACA;AACA;AACA;AACA;IACAC;MACA;MACA;QACAC;QACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;YACAC;UACA;UACA;UACA;UACA;UACA;YACAA;UACA;UACA;UACA;UACA;UACA;YACAA;UACA;UACA;UACA;UACA;UACA;YACAA;UACA;UACAD;QACA;MACA;MACA;MACA;QACA;UACA;QACA;MACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAE;MACA;MACA;QACA;UACA;YACA;YACA;YACA;YACA;YACA;YACA,IACA,kCACAC,aACAA,qBACAC,aACAA,sBACA,+DACA;cACAC;YACA;UACA;QACA;MACA;MACA;IACA;IACA;AACA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;QACAC;UACAC;QACA;MACA;IACA;IACA;AACA;AACA;IACAC;MACA;QACA;UACA;UACA;YACA;UACA;YACA;UACA;QACA;MACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;QACA;UACA;YACAC;UACA;QACA;MACA;MACA;IACA;IACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACA;QACA;MACA;QACA;MACA;IACA;EACA;AACA","names":["components","props","message","default","type","importToken","currentSpeed","data","width","height","gridList","currentTick","cellCount","cellsAlive","cellsCreated","isMouseDown","computed","watch","created","methods","cellCalc","isAlive","setCell","update","tempArr","result","getNeighbours","newX","newY","neighbours","reset","col","cell","randomSeed","exportSession","exportToken","updateCellCount"],"sourceRoot":"src/components","sources":["GridBoard.vue"],"sourcesContent":["<template>\n  <div>\n    <app-stats\n      :current-tick=\"currentTick\"\n      :cell-count=\"cellCount\"\n      :cells-alive=\"cellsAlive\"\n      :cells-created=\"cellsCreated\"\n      :current-speed=\"currentSpeed\"\n    />\n    <div\n      class=\"game-grid columns\"\n      @mousedown=\"isMouseDown = true\"\n      @mouseup=\"isMouseDown = false\"\n      @mouseleave=\"isMouseDown = false\"\n    >\n      <div v-for=\"(col, indexX) in gridList\" :key=\"indexX\" class=\"game-column\">\n        <app-cell\n          v-for=\"(isAlive, indexY) in col\"\n          :key=\"indexY\"\n          :status-obj=\"isAlive\"\n          :x-pos=\"indexX\"\n          :y-pos=\"indexY\"\n          :is-mouse-down=\"isMouseDown\"\n          @wasUpdated=\"updateCellCount\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport Cell from \"@/components/GridCell.vue\";\nimport Stats from \"@/components/StatsApp.vue\";\nexport default {\n  components: {\n    \"app-cell\": Cell,\n    \"app-stats\": Stats,\n  },\n  props: {\n    message: {\n      default: \"\",\n      type: String,\n    },\n    importToken: {\n      default: \"\",\n      type: String,\n    },\n    currentSpeed: {\n      default: 0,\n      type: Number,\n    },\n  },\n  data() {\n    return {\n      width: 46,\n      height: 20,\n      gridList: [],\n      // Stats that get passed down to the app-stats component\n      currentTick: 0,\n      cellCount: 0,\n      cellsAlive: 0,\n      cellsCreated: 0,\n      // A prop that gets used by the app-cell component (drag)\n      isMouseDown: false,\n    };\n  },\n  computed: {},\n  watch: {\n    /**\n     * Watches for changes in the message prop\n     * that gets passed down from the App component\n     * and then handles the input on a specific tick.\n     *\n     * @param {string} val - the value\n     */\n    message: function (val) {\n      if (val === \"nextStep\") {\n        this.update();\n        this.currentTick++;\n      } else if (val === \"redoSession\") {\n        this.reset();\n      } else if (val === \"randomSeed\") {\n        this.randomSeed();\n      }\n    },\n  },\n  created() {\n    this.cellCalc();\n  },\n  methods: {\n    /**\n     * Creates a 2D-Array during runtime for\n     * the website to use for most operations.\n     */\n    cellCalc: function () {\n      for (let i = 0; i < this.width; i++) {\n        this.gridList[i] = [];\n        for (let j = 0; j < this.height; j++) {\n          this.gridList[i][j] = { isAlive: false };\n        }\n      }\n      this.cellCount = this.width * this.height;\n    },\n    /**\n     * Changes the 'isAlive' object property\n     * of a specific cell to the one requested\n     * in the param.\n     *\n     * Usage to describe params\n     *\n     * @param {number} x - the x position\n     * @param {number} y - the y position\n     * @param {boolean} bool - the new boolean\n     */\n    setCell: function (x, y, bool) {\n      if (this.gridList[x][y].isAlive != bool) {\n        this.gridList[x][y].isAlive = bool;\n        this.updateCellCount(bool);\n      }\n      // let row = this.gridList[x];\n      // row.splice(y, 1, {isAlive: true});\n      // this.gridList.splice(x, 1, row);\n    },\n    /**\n     * The main function that updates the grid\n     * every tick based on the game of life rules.\n     */\n    update: function () {\n      let tempArr = [];\n      for (let i = 0; i < this.width; i++) {\n        tempArr[i] = [];\n        for (let j = 0; j < this.height; j++) {\n          let status = this.gridList[i][j].isAlive;\n          let neighbours = this.getNeighbours(i, j);\n          let result = false;\n          // Rule 1:\n          // Any live cell with fewer than two live neighbours dies,\n          // as if by under population\n          if (status && neighbours < 2) {\n            result = false;\n          }\n          // Rule 2:\n          // Any live cell with two or three neighbours lives on\n          // to the next generation\n          if ((status && neighbours == 2) || neighbours == 3) {\n            result = true;\n          }\n          // Rule 3:\n          // Any live cell with more than three live neighbours dies,\n          // as if by overpopulation\n          if (status && neighbours > 3) {\n            result = false;\n          }\n          // Rule 4:\n          // Any dead cell with exactly three live neighbours becomes\n          // a live cell, as if by reproduction\n          if (!status && neighbours == 3) {\n            result = true;\n          }\n          tempArr[i][j] = result;\n        }\n      }\n      // set new gridList content\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          this.setCell(i, j, tempArr[i][j]);\n        }\n      }\n    },\n    /**\n     * Returns the amount of neighbours for\n     * a specific cell on the grid.\n     *\n     * @param {number} posX - the x position\n     * @param {number} posY - the Y position\n     * @return {number} neighbours - amount of neighbours\n     */\n    getNeighbours: function (posX, posY) {\n      let neighbours = 0;\n      if (posX <= this.width && posY <= this.height) {\n        for (let offsetX = -1; offsetX < 2; offsetX++) {\n          for (let offsetY = -1; offsetY < 2; offsetY++) {\n            let newX = posX + offsetX;\n            let newY = posY + offsetY;\n            // check if offset is:\n            // on current cell, out of bounds and if isAlive\n            // for cell true\n            if (\n              (offsetX != 0 || offsetY != 0) &&\n              newX >= 0 &&\n              newX < this.width &&\n              newY >= 0 &&\n              newY < this.height &&\n              this.gridList[posX + offsetX][posY + offsetY].isAlive == true\n            ) {\n              neighbours++;\n            }\n          }\n        }\n      }\n      return neighbours;\n    },\n    /**\n     * Resets all gridList cells back to the\n     * start value.\n     */\n    reset: function () {\n      this.currentTick = 0;\n      this.cellsAlive = 0;\n      this.cellsCreated = 0;\n      this.gridList.forEach((col) => {\n        col.forEach((cell) => {\n          cell.isAlive = false;\n        });\n      });\n    },\n    /**\n     * Populates and overwrites gridList with cells.\n     */\n    randomSeed: function () {\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          let rand = Math.random();\n          if (rand < 0.2) {\n            this.setCell(i, j, true);\n          } else {\n            this.setCell(i, j, false);\n          }\n        }\n      }\n    },\n    /**\n     * Resets and then imports new cells into the gridList\n     * based on the importToken prop that gets passed down\n     * App.vue.\n     * The importToken is a string and its syntax looks\n     * like this:\n     * '[xPos,yPos],[xPos,yPos]...'.\n     */\n    /**\n     * Uses gridList to create an exportToken and\n     * emits it up to App.vue for the user to copy.\n     * Same format as in importToken().\n     */\n    exportSession: function () {\n      let exportToken = \"\";\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          if (this.gridList[i][j].isAlive) {\n            exportToken += \"[\" + i + \",\" + j + \"]\";\n          }\n        }\n      }\n      this.$emit(\"exportToken\", exportToken);\n    },\n    /**\n     * Updates the current cellcount on each new tick.\n     *\n     * @param {boolean} bool - boolean based on cell isAlive status\n     */\n    updateCellCount: function (bool) {\n      if (bool) {\n        this.cellsAlive++;\n        this.cellsCreated++;\n      } else {\n        this.cellsAlive--;\n      }\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\">\n.game-grid {\n  border-top: 1px solid #1a0707;\n  border-left: 1px solid #1a0707;\n  display: flex;\n  flex: 1;\n  justify-content: center;\n}\n.game-column {\n  flex: 1;\n  display: flex;\n  justify-content: center;\n  padding: 0;\n  margin: 0 auto;\n  flex-direction: column;\n}\n</style>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}